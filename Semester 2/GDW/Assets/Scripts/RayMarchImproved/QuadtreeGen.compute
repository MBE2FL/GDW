// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "../../../Library/PackageCache/com.unity.render-pipelines.core@7.3.1/ShaderLibrary/Common.hlsl"
#include "../RayMarch/Graphics Pipeline/Shaders/PrimitiveFunctions.hlsl"
#include "../RayMarch/Graphics Pipeline/Shaders/ConditionalFunctions.hlsl"
#include "../RayMarch/Graphics Pipeline/Shaders/RayMarchCommonFunctions.hlsl"



struct PixelOutput
{
    float4 sceneCol : SV_Target0;
    float distMap : SV_Tar;
    float depth : SV_Depth;
};

sampler2D _performanceRamp;
RWTexture2D<float4> _sceneCol;
Texture2D<float4> _depthTex;
RWTexture2D<float4> _distTex;
    
/// ######### RM OBJS Information #########
static const uint MAX_RM_OBJS = 32;
static const uint MAX_CSG_CHILDREN = 16;
float4x4 _invModelMats[MAX_RM_OBJS];
float4 _rm_colours[MAX_RM_OBJS];
int _primitiveTypes[MAX_RM_OBJS];
float2 _combineOps[MAX_RM_OBJS];
float4 _primitiveGeoInfo[MAX_RM_OBJS];
float4 _reflInfo[MAX_RM_OBJS];
float4 _altInfo[MAX_RM_OBJS];

float4 _bufferedCSGs[MAX_CSG_CHILDREN];
float4 _combineOpsCSGs[MAX_CSG_CHILDREN];

float4 _boundGeoInfo[MAX_RM_OBJS];
    /// ######### RM OBJS Information #########
float distBuffer[MAX_RM_OBJS];

float4x4 _cameraInvMatrix;
float4x4 _camLocalToWorldMatrix;
float4x4 _cameraToWorldMatrix;
float4x4 _cameraToWorldInvMatrix;
float4x4 _cameraInvProj;

float _totalTime;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
//RWTexture2D<float4> Result;



float3 generateCameraRay(float2 uv);


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
    
    
    
    uint width, height;
    _sceneCol.GetDimensions(width, height);
    float2 uv = (id.xy / float2(width, height) * 2.0) - 1.0;
   
    
    
    //float3 rayDir = -viewDirection;
    float3 rayDir = generateCameraRay(uv);
    // WHY NEW UNITY (View ray faces towards the camera)

    // Ray origin
    float3 rayOrigin = _CameraPos.xyz;

    // #if UNITY_UV_STARTS_AT_TOP
    // if (_MainTex_TexelSize.y < 0)
    //     uv.y = 1 - uv.y;
    // #endif

        
    // Convert from depth buffer (eye space) to true distance from camera.
    // This is done by multiplying the eyespace depth by the length of the "z-normalized" ray.
    // Think of similar triangles:
    // The view-space z-distance between a point and the camera is proportional to the absolute distance.
    //float linearEyeDepth = LinearEyeDepth(posInput.positionWS, UNITY_MATRIX_V);
    //linearEyeDepth = LinearEyeDepth(depth, _ZBufferParams);
    //float linearEyeDepth = posInput.linearDepth;
    float linearEyeDepth = LinearEyeDepth(_CameraPos, _cameraInvMatrix); // Wrong
    linearEyeDepth = _depthTex[id.xy].r;
    
    
    // Convert ray direction from world space to eyespace(camera).
    float3 zNormRayDir = mul(_cameraToWorldInvMatrix, float4(rayDir, 0.0)).xyz;
    // "Normalize" ray direction in the z-axis.
    // Dividing by z "normalizes" it in the z axis.
    // Therefore multiplying the ray by some number i gives the viewspace position
    // of the point on the ray with [viewspace z] = i.
    zNormRayDir /= abs(zNormRayDir.z);
    // Convert new ray direction from eyespace(camera) to world space.
    zNormRayDir = mul(_cameraToWorldMatrix, float4(zNormRayDir, 0.0)).xyz;
    // Multiply the eyespace depth by the length of "z-nomralized" ray direction.
    linearEyeDepth *= length(zNormRayDir);
    //linearEyeDepth = 400.0;
    
    
    //rayDir = zNormRayDir;
    
    //rayDir = normalize(rayDir);
    

    // Colour of the scene before this shader was run
    float4 col = _sceneCol[id.xy];

    // March a ray for each pixel, and check whether anything was hit.
    float3 p = float3(0.0, 0.0, 0.0);
    rmPixel distField;
    float4 add = float4(0.0, 0.0, 0.0, 0.0);
    float3 normal = float3(0.0, 0.0, 0.0);
    int rayHit = cheapRaymarch(rayOrigin, rayDir, linearEyeDepth, _maxSteps, _maxDrawDist, p, distField);
    rayHit = raymarch(rayOrigin, rayDir, linearEyeDepth, _maxSteps, _maxDrawDist, p, distField, rayHit);

    // Perform shading/lighting.
    if (rayHit)
    {
        normal = calcNormal(p);
        add = calcLighting(p, normal, distField);
        //add = float4(1.0, 0.0, 0.0, 1.0);

        // float2 ratio = fresnel(distField.refractInfo.y, rayDir, normal);
        // ratio.x = (distField.refractInfo.x > 0.0) ? ratio.x : 1.0;

        // // Perform refraction
        // //performRefraction(add, rayOrigin, rayDir, p, normal, distField, ratio);
        // //ReflectAndRefract(add, rayOrigin, rayDir, p, normal, distField, ratio);
        // //cheapRefract(add, rayOrigin, rayDir, p, normal, distField, ratio);

        // // Perform reflection
        // reflection(add, rayOrigin, rayDir, p, normal, distField, ratio);
        
        col = float4(add.rgb, 1.0);
    }
    //else
    //{
    //    //col = float4(abs(cos(_totalTime)), abs(sin(_totalTime)), 0.0, 1.0);
    //    //col = float4(rayDir.xyz, 1.0);
    //    col = float4(rayHit.xxx, 0.0);
    //    //col = float4(rayDir.xyz, 1.0);
    //}
        

    //add = float4(tex2D(_performanceRamp, float2(distField.dist, 0.0)).xyz, 1.0);
    //add = float4(tex2D(_performanceRamp, float2(distField.totalDist / _maxDrawDist, 0.0)).xyz, 1.0);

    // Returns final colour using alpha blending.
    //col = float4(lerp(col.rgb, add.rgb, add.a), 1.0);
    _sceneCol[id.xy] = col;
    //_sceneCol[id.xy] = float4(linearEyeDepth.xxx / 10, 1.0);
    //_sceneCol[id.xy] = float4(rayDir.xyz, 1.0);
    //_sceneCol[id.xy] = float4(zNormRayDir.xyz, 1.0);
}


float3 generateCameraRay(float2 uv)
{
    //float3 origin = mul(_cameraToWorldMatrix, float4(0.0, 0.0, 0.0, 1.0)).xyz;
    float3 dir = mul(_cameraInvProj, float4(uv, 0.0, 1.0)).xyz;
    
    dir = mul(_cameraToWorldMatrix, float4(dir, 0.0)).xyz;
    dir = normalize(dir);
    
    return dir;
}




float cheapMap(float3 p)
{
    float scene = _maxDrawDist;

    float4 pos = float4(0.0, 0.0, 0.0, 0.0);
    float4 geoInfo = float4(0.0, 0.0, 0.0, 0.0);
    float radius = 0.0;

    float obj;

	// ######### New Game Object #########
    pos = mul(_invModelMats[0], float4(p, 1.0));
    geoInfo = _boundGeoInfo[0];
    obj = sdSphere(pos.xyz, geoInfo.x);

    scene = opSmoothUnion(scene, obj, _combineOps[0].y);
	// ######### New Game Object #########
    
    // ######### New Game Object #########
    pos = mul(_invModelMats[1], float4(p, 1.0));
    geoInfo = _boundGeoInfo[1];
    obj = sdBox(pos.xyz, geoInfo.xyz);

    scene = opSmoothUnion(scene, obj, _combineOps[1].y);
	// ######### New Game Object #########


    return scene;
	//<Insert Cheap Map Here>
}

	/// Distance field function.
	/// The distance field represents the closest distance to the surface of any object
	/// we put in the scene. If the given point (point p) is inside of any object, we return an negative answer.
	/// Return.x: Distance field value.
	/// Return.y: Colour of closest object (0 - 1).
float map(float3 p)
{
    float scene = _maxDrawDist;

    float4 pos = float4(0.0, 0.0, 0.0, 0.0);
    float4 geoInfo = float4(0.0, 0.0, 0.0, 0.0);

    float obj;
    float obj2;

    float csg;
    float storedCSGs[MAX_CSG_CHILDREN];

    float3 cell = float3(0.0, 0.0, 0.0);

	// ######### New Game Object #########
    pos = mul(_invModelMats[0], float4(p, 1.0));
    geoInfo = _primitiveGeoInfo[0];
    obj = sdSphere(pos.xyz, geoInfo.x);
    distBuffer[0] = obj;

    scene = opSmoothUnion(scene, obj, _combineOps[0].y);
	// ######### New Game Object #########
    
    // ######### New Game Object #########
    pos = mul(_invModelMats[1], float4(p, 1.0));
    geoInfo = _primitiveGeoInfo[1];
    obj = sdBox(pos.xyz, geoInfo.xyz);
    distBuffer[1] = obj;

    scene = opSmoothUnion(scene, obj, _combineOps[1].y);
	// ######### New Game Object #########

    return scene;
}

rmPixel mapMat()
{
    rmPixel scene;
    scene.dist = _maxDrawDist;
    scene.colour = float4(0.0, 0.0, 0.0, 0.0);
    scene.reflInfo = float4(0.0, 0.0, 0.0, 0.0);
    scene.refractInfo = float2(0.0, 1.0);
    scene.texID = 0;

    rmPixel obj;
    obj.colour = float4(0.0, 0.0, 0.0, 0.0);
    obj.reflInfo = float4(0.0, 0.0, 0.0, 0.0);
    obj.refractInfo = float2(0.0, 1.0);
    obj.texID = 0;

    rmPixel obj2;
    obj2.colour = float4(0.0, 0.0, 0.0, 0.0);
    obj2.reflInfo = float4(0.0, 0.0, 0.0, 0.0);
    obj2.refractInfo = float2(0.0, 1.0);
    obj2.texID = 0;

    rmPixel csg;
    csg.colour = float4(0.0, 0.0, 0.0, 0.0);
    csg.reflInfo = float4(0.0, 0.0, 0.0, 0.0);
    csg.refractInfo = float2(0.0, 1.0);
    csg.texID = 0;
    rmPixel storedCSGs[MAX_CSG_CHILDREN];

    float reflWeight;
	// ######### New Game Object #########
    obj.dist = distBuffer[0];
    obj.colour = _rm_colours[0];
    obj.reflInfo = _reflInfo[0];
    obj.refractInfo = _refractInfo[0];
    scene = opSmoothUnionMat(scene, obj, _combineOps[0].y);
	// ######### New Game Object #########
    
    // ######### New Game Object #########
    obj.dist = distBuffer[1];
    obj.colour = _rm_colours[1];
    obj.reflInfo = _reflInfo[1];
    obj.refractInfo = _refractInfo[1];
    scene = opSmoothUnionMat(scene, obj, _combineOps[1].y);
	// ######### New Game Object #########


    return scene;
}
