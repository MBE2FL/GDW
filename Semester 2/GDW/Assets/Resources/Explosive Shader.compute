// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main

RWStructuredBuffer<float3x3> dataBuffer;
RWStructuredBuffer<float3x3> normBuffer;

float3 GetNormal(float3 a, float3 b, float3 c)
{
   float3 d = a-b;
   float3 e = c-b;
   return normalize(cross(d, e));
}

float3 Explode(float3 position, float3 normal)
{
    return position + normal;
}

float3 Move(float3 pos, int i)
{
    pos.y = pos.y - i * 0.01;
    return pos;
}

float3 MakeNormal(float3 a, float3 b, float3 c)
{
    float3 result;// = lerp(a, b, 0.5);
    //result = lerp(result, c, 0.5);
    result = normalize(a+b+c);
    return result;
}

[numthreads(1024,1,1)]
void Main (uint3 id : SV_DispatchThreadID)
{
    float3x3 input;

    input = normBuffer[id.x];

    float3 n1 = float3(input[0][0], input[0][1], input[0][2]);
    float3 n2 = float3(input[1][0], input[1][1], input[1][2]);
    float3 n3 = float3(input[2][0], input[2][1], input[2][2]);

    input = dataBuffer[id.x];

    float3 p1 = float3(input[0][0], input[0][1], input[0][2]);
    float3 p2 = float3(input[1][0], input[1][1], input[1][2]);
    float3 p3 = float3(input[2][0], input[2][1], input[2][2]);

    

    float3 norm = MakeNormal(n1,n2,n3);

    p1 = Explode(p1,norm);
    p2 = Explode(p2,norm);
    p3 = Explode(p3,norm);
    
    input[0][0] = p1.x;
    input[0][1] = p1.y;
    input[0][2] = p1.z;

    input[1][0] = p1.x;
    input[1][1] = p1.y;
    input[1][2] = p1.z;

    input[2][0] = p1.x;
    input[2][1] = p1.y;
    input[2][2] = p1.z;

    dataBuffer[id.x] = input;
}
